
Calculator >>> x y == 3
New symbol: y
False
Calculator >>> ast.parse("x*y == 3") 
<ast.Module object at 0x000001E098EB7430>
Calculator >>> ast.parse("x*y == 3").body[0] 
<ast.Expr object at 0x000001E098EB6FE0>
Calculator >>> ast.parse("x*y == 3").body[0].value
<ast.Compare object at 0x000001E098EB7F10>
Calculator >>> dir(_)
[__class__, __delattr__, __dict__, __dir__, __doc__, __eq__, __format__, __ge__, __getattribute__, __gt__, __hash__, __init__, __init_subclass__, __le__, __lt__, __match_args__, __module__, __ne__, __new__, __reduce__, __reduce_ex__, __repr__, __setattr__, __sizeof__, __str__, __subclasshook__, __weakref__, _attributes, _fields, col_offset, comparators, end_col_offset, end_lineno, left, lineno, ops]  
Calculator >>> ast.parse("x*y == 3").body[0].value.ops
[<ast.Eq object at 0x000001E095013F10>]
Calculator >>> ast.parse("x*y == 3 == 4").body[0].value.ops 
[<ast.Eq object at 0x000001E095013F10>, <ast.Eq object at 0x000001E095013F10>]
Calculator >>>



make a warning for this



# outputdecimal may time out
# nintegrate is still sad
# use regex on notationinterval 
# nCr and nPr

# write docs on everythign
# installing
# save (like ipynb)
# Logging

Calculator >>> integrate(exp(1/x**2)sin(x),(x,1,10))
New symbol: x (then send ctrl+c)
Calculator >>> ^C
C:\Users\Chester\Documents>
https://docs.python.org/3/library/signal.html


Calculator >>> 3x=4x
Parsed Command: 3x=4x
Resent command: 3*x=4x
Resent command: 3*x=4*x
Traceback (most recent call last):
  File "C:\Users\Chester\Code Projects\friendly-sympy\symcalc\calc.py", line 322, in command
    compiled = code.compile_command(command_data.command)
  File "C:\Users\Chester\AppData\Local\Programs\Python\Python310\lib\codeop.py", line 139, in compile_command
    return _maybe_compile(_compile, source, filename, symbol)
  File "C:\Users\Chester\AppData\Local\Programs\Python\Python310\lib\codeop.py", line 102, in _maybe_compile
    raise err1
  File "C:\Users\Chester\AppData\Local\Programs\Python\Python310\lib\codeop.py", line 91, in _maybe_compile
    code1 = compiler(source + "\n", filename, symbol)
  File "C:\Users\Chester\AppData\Local\Programs\Python\Python310\lib\codeop.py", line 118, in _compile
    return compile(source, filename, symbol, PyCF_DONT_IMPLY_DEDENT)
  File "<input>", line 1
    3*x=4*x
    ^^^
SyntaxError: cannot assign to expression here. Maybe you meant '==' instead of '='?
(return a condition instead)

help command

keyword based "solve" "derviative"

if mathfunction is called with a callable arg, return a mathfunction
end line nos
tests

origin vectors are dynamic 